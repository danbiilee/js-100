# ë¬¸ì œ73 : ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°

[ â“ ] ë‹¤ìŒê³¼ ê°™ì´ ë…¸ë“œì˜ ì—°ê²° ê´€ê³„ê°€ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ê·¸ë‹¤ìŒ ê²½ë¡œë¥¼ êµ¬í•  ë‘ ì •ì ì´ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ì£¼ì–´ì§ˆ ê²ƒì…ë‹ˆë‹¤.

ë‘ ì •ì  ì‚¬ì´ë¥¼ ì´ë™í•  ìˆ˜ ìˆëŠ” ìµœë‹¨ ê±°ë¦¬ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•´ ì£¼ì„¸ìš”.

ì´ë•Œ ìµœë‹¨ ê±°ë¦¬ë€, ì •ì ì˜ ì¤‘ë³µ ì—†ì´ í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ê¹Œì§€ ê°ˆ ìˆ˜ ìˆëŠ” ê°€ì¥ ì ì€ ê°„ì„ ì˜ ìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.

```
ë°ì´í„°
graph = {'A': ['B', 'C'],
         'B': ['A', 'D', 'E'],
         'C': ['A', 'F'],
         'D': ['B'],
         'E': ['B', 'F'],
         'F': ['C', 'E']}

ì…ë ¥
A F

ì¶œë ¥
2
```

![](./../img/073-bfs.PNG)

## ğŸ’¡ ë‚´ ì½”ë“œ

ë‚˜ëŠ” Fê¹Œì§€ ê°€ëŠ” íšŸìˆ˜ë¥¼ ì°¾ì€ê±°ì§€ ì´ê±´ ìµœë‹¨ ê±°ë¦¬ê°€ ì•„ë‹ˆìŸˆë‚˜ã… ã… 

```js
const nodes = 'A F'.split(' ');

const bfs = (graph, nodes) => {
  const visited = [];
  let queue = [nodes[0]];
  let count = 0;

  while (queue.length > 0) {
    const n = queue.shift();
    if (!visited.includes(n)) {
      visited.push(n);
      if (n === nodes[1]) {
        console.log(`visited: ${visited}`);
        queue = [];
      } else {
        const sub = graph[n].filter((g) => !visited.includes(g));
        for (let s of sub) {
          queue.push(s);
        }
        count++;
      }
    }
  }
  return count;
};

console.log(bfs(graph, nodes));
```

## âœ”ï¸ ë‹µì•ˆ

```js
const user_input = prompt('ì…ë ¥í•´ì£¼ì„¸ìš”').split(' ');
const start = user_input[0];
const end = user_input[1];

// ì²˜ìŒì— ì‹œì‘ ë…¸ë“œë¥¼ ë‹´ì•„ë‘¬ì•¼ whileë¬¸ì— ì§„ì…í•  ìˆ˜ ìˆë‹¤
let queue = [start];
let visited = [start];

function solution() {
  // ë…¸ë“œ Aì—ì„œ ì‹œì‘í•˜ëŠ” ìˆœê°„ countê°€ 1ì´ ë˜ì•¼í•˜ë¯€ë¡œ
  // ì²˜ìŒì—” -1ë¡œ ì‹œì‘
  let count = -1;

  while (queue.length !== 0) {
    // í ìˆœíšŒë¬¸ ë°”ê¹¥ì—ì„œ ì¹´ìš´íŠ¸ë¥¼ í•´ì¤˜ì•¼
    // ê±°ë¦¬1, ê±°ë¦¬2ë§ˆë‹¤ í•œ ë²ˆì”©ë§Œ ì¹´ìš´íŠ¸ê°€ ëœë‹¤
    count += 1;

    let size = queue.length;

    // íì˜ ì‚¬ì´ì¦ˆë§Œí¼ ìˆœíšŒ
    for (let i = 0; i < size; i++) {
      // íì—ì„œ ì²«ë²ˆì§¸ ë…¸ë“œ êº¼ëƒ„
      let node = queue.splice(0, 1);

      // êº¼ë‚¸ ë…¸ë“œê°€ ì¢…ë£Œ ë…¸ë“œì™€ ê°™ë‹¤ë©´ ë©ˆì¶¤
      if (node == end) {
        return count;
      }

      // for...in: ìš”ì†Œì˜ ê°’ì´ ì•„ë‹Œ ì¸ë±ìŠ¤ë¡œ
      for (let next_node in graph[node]) {
        if (!visited.includes(graph[node][next_node])) {
          visited.push(graph[node][next_node]);
          queue.push(graph[node][next_node]);
        }
      }
    }
  }
}
console.log(solution());
```

---

## ğŸ“Œ ì¶”ê°€

ë‚´ ê¸°ì¤€ ë” ì•Œì•„ë³´ê¸° ì‰½ê²Œ ë³€ê²½í•œ ì½”ë“œ.
ê·¼ë° ì™œ ë°©ë¬¸ê²½ë¡œë‘ íì— ê°™ì´ í‘¸ì‹œí•˜ëŠ”ì§€ ì˜ ì´í•´ê°€ ì•ˆê°.

```js
const bfs = (graph, nodes) => {
  const visited = [nodes[0]];
  const queue = [nodes[0]];
  let count = -1;

  while (queue.length > 0) {
    count++;
    for (let i = 0; i < queue.length; i++) {
      const n = queue.shift();
      if (n === nodes[1]) {
        return count;
      }
      const sub = graph[n].filter((g) => !visited.includes(g));
      for (let s of sub) {
        visited.push(s);
        queue.push(s);
      }
    }
  }
  return count;
};
```
